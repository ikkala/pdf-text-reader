import {join} from 'node:path';
import {getDocument} from 'pdfjs-dist';
import type {
    DocumentInitParameters,
    PDFPageProxy,
    TextItem,
} from 'pdfjs-dist/types/src/display/api.js';
import type {RequireExactlyOne} from 'type-fest';

export type {DocumentInitParameters} from 'pdfjs-dist/types/src/display/api.js';

/** A single page within a PDF file. */
export type PdfPage = {
    lines: string[];
};

/** Progress updates sent by the `pdfjs-dist` dependency. */
export type PdfProgressData = {
    loaded: number;
    total: number;
};

/**
 * Same as the built-in Partial type but also allows each property to be undefined. Compatible with
 * PartialAndUndefined from @augment-vir/common.
 */
export type PartialWithUndefined<T extends object> = {
    [Prop in keyof T]?: T[Prop] | undefined;
};

/** All options for reading pdf text to function. Most are optional. */
export type ReadPdfTextParams = PartialWithUndefined<{
    /** Password used to open a PDF that's password protected. */
    password: string;
    /** This callback will be periodically called while PDF reading is in progress. */
    progressCallback: (progressData: PdfProgressData) => void;
    /**
     * Set this as an absolute path to the `pdfjs-dist` directory in your `node_modules` directory.
     * This is not required for proper operation, but may help with a warning like the following:
     *
     * Warning: fetchStandardFontData: failed to fetch file "<font name>" with
     * "UnknownErrorException: The standard font "baseUrl" parameter must be specified, ensure that
     * the "standardFontDataUrl" API parameter is provided.".
     *
     * For more details see https://github.com/mozilla/pdf.js/issues/4244
     *
     * Example: /home/ubuntu/this-repo/node_modules/pdfjs-dist
     */
    pathToPdfJsDistNodeModule: string;
    /**
     * All options that the Mozilla's `pdfjs-dist` package supports. This will override any options
     * that this package passes to `pdfjs-dist`.
     */
    options: Partial<Omit<DocumentInitParameters, 'data' | 'url'>>;
}> &
    RequireExactlyOne<{
        /** File path to the PDF file to read. */
        filePath: NonNullable<DocumentInitParameters['url']>;
        /** URL to the PDF. */
        url: NonNullable<DocumentInitParameters['url']>;
        /** PDF file data that has already been read from a PDF file. */
        data: NonNullable<DocumentInitParameters['data']>;
    }>;

/**
 * Read a PDF and convert it into lines of text.
 *
 * If a URL is used to fetch the PDF data a standard XMLHttpRequest(XHR) is used, which means it
 * must follow the same origin rules that any XHR does e.g. No cross domain requests without CORS.
 */
export async function readPdfPages({
    data,
    filePath,
    password,
    pathToPdfJsDistNodeModule,
    progressCallback,
    url,
    options,
}: ReadPdfTextParams): Promise<PdfPage[]> {
    const documentLoadingTask = getDocument({
        data,
        url: url || filePath,
        useSystemFonts: true,
        password,
        standardFontDataUrl: pathToPdfJsDistNodeModule
            ? join(pathToPdfJsDistNodeModule, 'standard_fonts')
            : undefined,
        ...options,
    });
    if (progressCallback) {
        documentLoadingTask.onProgress = progressCallback;
    }

    const document = await documentLoadingTask.promise;

    const pageCount = document.numPages;

    const pages: PdfPage[] = [];

    for (let i = 0; i < pageCount; i++) {
        const page = await document.getPage(i + 1);
        pages.push(await parsePage(page));
    }

    /** This is populated by the pdfjs-dist package. We're deleting it here to prevent memory leaks. */
    delete (globalThis as any).pdfjsWorker;

    return pages;
}

/** Reads a PDF into a single string. */
export async function readPdfText(params: ReadPdfTextParams): Promise<string> {
    const pdfPages = await readPdfPages(params);
    return combinePagesIntoSingleString(pdfPages);
}

/** Combine all PDF pages into a single string. */
export function combinePagesIntoSingleString(pages: PdfPage[]): string {
    return pages
        .map((page) => page.lines)
        .flat()
        .join('\n');
}

/** Parse a single PDF page. */
export async function parsePage(pdfPage: PDFPageProxy): Promise<PdfPage> {
    const rawContent = await pdfPage.getTextContent();
    return parsePageItems(rawContent.items.filter((item): item is TextItem => 'str' in item));
}

/**
 * Parses individual text items generated by pdf.js This allows lower level control of what actually
 * gets parsed. For example, a consumer of this function may remove entire sections of the pdf text
 * prior to passing items in here. See parsePage function above for example usage.
 *
 * @param pdfItems An array of TextItem items.
 */
export function parsePageItems(pdfItems: TextItem[], addSpace = false): PdfPage {
    const lineData: {[y: number]: TextItem[]} = {};

    for (let i = 0; i < pdfItems.length; i++) {
        const item = pdfItems[i];
        const y = item?.transform[5];
        if (!lineData.hasOwnProperty(y)) {
            lineData[y] = [];
        }
        // how how to intentionally test this
        /* istanbul ignore next */
        if (item) {
            lineData[y]?.push(item);
        }
    }

    const yCoords = Object.keys(lineData)
        .map((key) => Number(key))
        // b - a here because the bottom is y = 0 so we want that to be last
        .sort((a, b) => b - a)
        // insert an empty line between any 2 lines where their distance is greater than the upper line's height
        .reduce((accum: number[], currentY, index, array) => {
            const nextY = array[index + 1];
            if (nextY != undefined) {
                const currentLine = lineData[currentY]!;
                const currentLineHeight: number = currentLine.reduce(
                    (finalValue, current) =>
                        finalValue > current.height ? finalValue : current.height,
                    -1,
                );

                // currentY - nextY because currentY will be higher than nextY
                if (Math.floor((currentY - nextY) / currentLineHeight) > 1) {
                    const newY = currentY - currentLineHeight;
                    lineData[newY] = [];
                    return accum.concat(currentY, newY);
                }
            }
            return accum.concat(currentY);
        }, []);

    const lines: string[] = [];
    for (let i = 0; i < yCoords.length; i++) {
        const y = yCoords[i];
        // idk how to actually test this
        /* istanbul ignore next */
        if (y == undefined) {
            continue;
        }
        // sort by x position (position in line)
        const lineItems = lineData[y]!.sort((a, b) => a.transform[4] - b.transform[4]).filter(
            (item) => !!item.str,
        );
        const firstLineItem = lineItems[0]!;
        let line = lineItems.length ? firstLineItem.str : '';
        for (let j = 1; j < lineItems.length; j++) {
            const item = lineItems[j]!;
            const lastItem = lineItems[j - 1]!;
            const xDiff = item.transform[4] - (lastItem.transform[4] + lastItem.width);

            // insert spaces for items that are far apart horizontally
            // idk how to trigger this
            /* istanbul ignore next */
            if (
                item.height !== 0 &&
                lastItem.height !== 0 &&
                (xDiff > item.height || xDiff > lastItem.height)
            ) {
                const spaceCountA = Math.ceil(xDiff / item.height);
                let spaceCount = spaceCountA;
                if (lastItem.height !== item.height) {
                    const spaceCountB = Math.ceil(xDiff / lastItem.height);
                    spaceCount = spaceCountA > spaceCountB ? spaceCountA : spaceCountB;
                }
                line += Array(spaceCount).fill('').join(' ');
            }
            line += (addSpace ? ' ' : '') + item.str;
        }
        lines.push(line);
    }

    return {
        lines,
    };
}
